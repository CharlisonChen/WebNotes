# 面试准备

## 0x00 TCP 三握四挥

- 传输层

  - 位于网络模型中间
  - 建立端到端的链接 --- 客户端 <-> 服务端
  - 端与端有各自的 ip 地址
  - ip 地址:端口号 --- 套接字 socket --- 握手之前的核心套件

- 三次握手

  - TCP 报文标识 SYN ACK FIN

    - 为 1 开启 为 0 关闭

  - 过程

    1. 首先客户端向服务端发送 SYN(synchronization) 标识，想跟服务端进行数据同步

       还发送了初始序号 seq = 8633

    2. 服务端开启 SYN + ACK 确认同步，生成序号：303 和 确认号：8633 + 1，发送给客户端，客户端根据确认号减一可推断是否为自己发送的报文

    3. 客户端开启 ACK 传回服务端表示确认收到，握手成功，建立连接，可开始发送 HTTP 请求

    ![image-20220211114517459](D:/DeepLearning/%E7%AC%94%E8%AE%B0/pictures/image-20220211114517459.png)

    <img src="D:/DeepLearning/%E7%AC%94%E8%AE%B0/pictures/image-20220211115008748.png" alt="image-20220211115008748" style="zoom: 50%;" />

- 四次挥手 --- 假设客户端发起
  - 过程
    1. 客户端将当前序号、确认号以及 FIN+ACK 打包发送给服务端，表示确认结束
    2. 服务端用客户端的确认号作序号，序号 + 1作确认号以及 ACK 标识打包发送给客户端，表示确认收到
    3. 服务端在把剩余数据传输完之后，按 2 中序号和确认号以及 FIN + ACK 标识打包发送给客户端，表示确认结束
    4. 客户端将收到的序号和确认号互换后 + 1 返回给服务端，表示确认结束，至此四次挥手结束

## 0x01 Promise

- 基本了解

  - 回调的升级版 --- 在处理一些要花费比较长时间的任务时，可以进行异步的处理，防止阻塞

  - <img src="D:/DeepLearning/%E7%AC%94%E8%AE%B0/pictures/image-20220211145646305.png" alt="image-20220211145646305" style="zoom:50%;" />

  - ```js
    const isPregnant = true
    
    const promise = new Promise((resolve, reject) => {
      if (isPregnant) {
        resolve(`孩子他爹`)
      } else {
        reject(`老公`)
      }
    })
    
    promise
      .then(name => {
        console.log(`男人成为了 ${name}`)
      })
      .catch(name => {
        console.log(`男人成为了 ${name}`)
      })
      .finally(() => {
        console.log(`结婚`)
      })
    ```

## 0x02 async & await

- 同步与异步
  - 多个异步处理将难以阅读代码，且造成多个事件积压
- 用同步编程的方式实现异步代码
  - aa 是基于 Promise 的语法糖
  - 若有返回值则为一个 Promise 对象
  - async 返回的是 Promise.resolve
  - await 不能单独使用，需配合 async 使用，async 是基于 Promise 使用的

## 0x03 跨域

- 浏览器的同源策略

  -  网页的请求还是会发送出去，但 js 拿不到返回的内容 --- 即不能跨过这个域访问其它域的功能	
  - 域 --- 协议 端口号 主机 一致的 URL

  <img src="D:/DeepLearning/%E7%AC%94%E8%AE%B0/pictures/image-20220211140258114.png" alt="image-20220211140258114" style="zoom: 33%;" />

  - 同源问题就是在 Ajax 或 Fetch 请求中存在访问问题

- 快速复习

  - <img src="D:/DeepLearning/%E7%AC%94%E8%AE%B0/pictures/image-20220211140749897.png" alt="image-20220211140749897" style="zoom:57%;" />
  - 

- JSONP --- JSON with padding

  - script 天然支持跨域，不受同源策略限制
  - 简单来说就是，现在 js 中定义一个和将要传回来的 js 代码中同名的函数，然后加载 script 标签，该script 标签会请求后端拿到数据，而这个数据刚好就是一串 js 代码，又因为这个代码里包含了我想要的不同源数据，浏览器执行这个代码时，我就能取到这个数据了
  - 缺点是只能 get

  > 就是用script标签请求get接口，拿到json数据被script当js执行，服务器返回的应当是内部return真实数据的js函数，并将函数转为json格式发给客户端

- CORS
  - 提前安装 CORS --- `npm install cors`
  - 简单来说就是设头部 `Access-Control-Allow-Origin`
  - 注意在服务器设置允许使用的方法
    - 当发生符合非简单请求（预检请求）的条件时，浏览器会自动先发送一个 options 请求，如果发现服务器支持该请求，则会将真正的请求发送到后端，反之，如果浏览器发现服务端并不支持该请求，则会在控制台抛出错误
  - 注意兼容问题 --- 需要浏览器与服务器同时支持
- 服务器反向代理
  - <img src="D:/DeepLearning/%E7%AC%94%E8%AE%B0/pictures/image-20220211144856081.png" alt="image-20220211144856081" style="zoom: 33%;" />
  - 

## 0x04 DNS 域名解析

> 域名转换为 ip 地址这一过程

- 域名结构树
- 域名服务器
  - 根域名服务器 --- .
  - 顶级域名服务器 --- com cn net gov
  - 权威域名服务器 --- bilibili qq baidu

- 域名解析过程

<img src="D:/DeepLearning/%E7%AC%94%E8%AE%B0/pictures/image-20220211153615310.png" alt="image-20220211153615310" style="zoom:57%;" />

1. 输入网址按下回车
2. 若浏览器、本地缓存没有 ip 地址
3. 向解析器发送解析请求 --- 浏览器 -> DNS 客户端
4. 向本地 DNS 服务器发送解析请求 --- DNS 客户端 -> 本地 DNS 服务器
5. 咨询根 --- 返回 com 服务器地址
6. 咨询 com --- 返回 name.com 服务器地址
7. 咨询 name.com --- 返回 www.name.com IP 地址
8. 递归返回给浏览器

## 0x05 正则表达式 10 例

### 手机号码

### QQ 号

### 邮箱

`([a-z0-9_\-\.]+)@([a-z1-9]{1,4})\.([a-zA-Z]{2,4})$`

### 网址

`^((https?|ftp|file):\/\/)?([\da-z\.\-]+)\.([a-z\.]{2,4})([\/\w\.\-]*)*\/?$`

### 匹配 HTML 标签

`<(?:[^"'>]|"[^"]*"|'[^']*')*>`

`(<[!/]?[a-zA-Z]+)([^>]*>)`

### 匹配 IP 地址

`^(([01]?[0-9][0-9]?|2[0-4][0-9]|25[0-5])\.){3}([01]?[0-9][0-9]?|2[0-4][0-9]|25[0-5])(:[0-9]+)?`

### 年-月-日

`([12][0-9]{3})\-(0[1-9]|1[0-2])\-(0[1-9]|[12][0-9]|3[01])`

### 车牌

`^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]$`

### 身份证

`^[1-9][0-9]{5}(18|19|([23][0-9]))[0-9]{2}(0[1-9]|1[0-2])(0[1-9]|[12][0-9])[0-9]{3}[0-9Xx]$`

